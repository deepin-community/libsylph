utils - ユーティリティ関数群

------------------------------------------------------------------------------
#define CHDIR_RETURN_IF_FAIL(dir)

カレントディレクトリを dir に変更します。失敗した場合は return します。

dir: カレントディレクトリの変更先のパス

------------------------------------------------------------------------------
#define CHDIR_RETURN_VAL_IF_FAIL(dir, val)

カレントディレクトリを dir に変更します。失敗した場合は return で val を
返します。

dir: カレントディレクトリの変更先のパス
val: 失敗時に返す値

------------------------------------------------------------------------------
#define Xalloca(ptr, size, iffail)

alloca(size) を実行し、 size バイトのメモリをスタック上に確保します。
失敗した場合は、 iffail に記述した文(複数の場合はブロック)を実行します。

ptr: 確保したメモリへのポインタ
size: 確保するメモリのサイズ
iffail: 失敗した場合に実行する文あるいはブロック

------------------------------------------------------------------------------
#define Xstrdup_a(ptr, str, iffail)

alloca() で確保したメモリに文字列 str をコピーします。
失敗した場合は、 iffail に記述した文(複数の場合はブロック)を実行します。

ptr: 確保したメモリへのポインタ
str: コピーする文字列
iffail: 失敗した場合に実行する文あるいはブロック

------------------------------------------------------------------------------
#define Xstrndup_a(ptr, str, len, iffail)

alloca() で確保したメモリに文字列 str を最大 len バイトコピーします。
末尾は常にヌル文字で終端されます。
失敗した場合は、 iffail に記述した文(複数の場合はブロック)を実行します。

ptr: 確保したメモリへのポインタ
str: コピーする文字列
len: コピーするバイト数
iffail: 失敗した場合に実行する文あるいはブロック

------------------------------------------------------------------------------
#define Xstrcat_a(ptr, str1, str2, iffail)

alloca() で確保したメモリに文字列 str1 と str2 を連結してコピーします。
失敗した場合は、 iffail に記述した文(複数の場合はブロック)を実行します。

ptr: 確保したメモリへのポインタ
str1: コピーする文字列1
str1: コピーする文字列2
iffail: 失敗した場合に実行する文あるいはブロック

------------------------------------------------------------------------------
#define AUTORELEASE_STR(str, iffail)

通常の g_malloc() で確保された文字列 str を alloca() で確保したものに
置き換えることで、後で g_free() を行わずに済むようにします。
失敗した場合は、 iffail に記述した文(複数の場合はブロック)を実行します。

str: 自動解放する文字列
iffail: 失敗した場合に実行する文あるいはブロック

------------------------------------------------------------------------------
#define FILE_OP_ERROR(file, func)

perror() を用いてファイル関連のエラーメッセージを出力します。

file: ファイル名
func: エラーの原因となった関数

------------------------------------------------------------------------------
typedef void (*UIUpdateFunc)		(void);

UI を強制的に更新する場合に呼び出されるコールバック関数の型です。

------------------------------------------------------------------------------
typedef void (*ProgressFunc)		(gint		 cur,
					 gint		 total);

進捗状況を表示するためのコールバック関数の型です。

cur: 現在のカウント
total: 総数

------------------------------------------------------------------------------
typedef gchar * (*QueryPasswordFunc)	(const gchar	*server,
					 const gchar	*user);

パスワードをユーザに入力させる場合に呼び出されるコールバック関数の型です。
パスワード文字列は新規にメモリを確保して返します。

server: サーバ名
user: ユーザ名
戻り値: 入力したパスワード文字列

------------------------------------------------------------------------------
typedef void (*LogFunc)			(const gchar	*str);

ログの出力時に呼び出されるコールバック関数の型です。

str: ログに出力する文字列

------------------------------------------------------------------------------
#define Str(x)	#x
#define Xstr(x)	Str(x)

引数 x を文字列に変換するためのマクロです。

------------------------------------------------------------------------------
void list_free_strings		(GList		*list);

g_malloc() で確保した文字列(あるいはその他のデータ)を要素に持つ GList
の各要素のメモリをすべて解放します。

list: g_malloc() で確保したメモリを要素に持つ GList

------------------------------------------------------------------------------
void slist_free_strings		(GSList		*list);

g_malloc() で確保した文字列(あるいはその他のデータ)を要素に持つ GSList
の各要素のメモリをすべて解放します。

list: g_malloc() で確保したメモリを要素に持つ GSList

------------------------------------------------------------------------------
void hash_free_strings		(GHashTable	*table);

g_malloc() で確保した文字列(あるいはその他のデータ)をキーとして持つ
GHashTable の各キーのメモリをすべて解放します。

table: g_malloc() で確保したメモリをキーとして持つ GHashTable

------------------------------------------------------------------------------
void hash_free_value_mem	(GHashTable	*table);

g_malloc() で確保した文字列(あるいはその他のデータ)を値として持つ
GHashTable の各値のメモリをすべて解放します。

table: g_malloc() で確保したメモリを値として持つ GHashTable

------------------------------------------------------------------------------
gint str_case_equal		(gconstpointer	 v,
				 gconstpointer	 v2);

g_hash_table_new() で使用するための比較関数です。
文字列 v と v2 が大小文字を区別せずに一致する場合 TRUE を返します。

v: 文字列1
v2: 文字列2
戻り値: 文字列 v と v2 が大小文字を区別せずに一致する場合 TRUE
        そうでない場合 FALSE

------------------------------------------------------------------------------
guint str_case_hash		(gconstpointer	 key);

g_hash_table_new() で使用するためのハッシュ関数です。
文字列 key をすべて小文字に変換した上でハッシュ値を生成します。

key: ハッシュのキー文字列
戻り値: 生成されたハッシュ値

------------------------------------------------------------------------------
void ptr_array_free_strings	(GPtrArray	*array);

g_malloc() で確保した文字列(あるいはその他のデータ)を要素に持つ GPtrArray
の各要素のメモリをすべて解放します。

list: g_malloc() で確保したメモリを要素に持つ GPtrArray

------------------------------------------------------------------------------
typedef gboolean (*StrFindFunc) (const gchar	*haystack,
				 const gchar	*needle);

文字列検索用の関数の型です。

haystack: 検索対象文字列
needle: 検索文字列
戻り値: 見つかった場合 TRUE
        見つからなかった場合 FALSE

------------------------------------------------------------------------------
gboolean str_find		(const gchar	*haystack,
				 const gchar	*needle);

文字列 haystack 中に文字列 needle が存在する場合に TRUE を返します。

haystack: 検索対象文字列
needle: 検索文字列
戻り値: 見つかった場合 TRUE
        見つからなかった場合 FALSE

------------------------------------------------------------------------------
gboolean str_case_find		(const gchar	*haystack,
				 const gchar	*needle);

文字列 haystack 中に文字列 needle が存在する場合に TRUE を返します。
大小文字は区別しません。

haystack: 検索対象文字列
needle: 検索文字列
戻り値: 見つかった場合 TRUE
        見つからなかった場合 FALSE

------------------------------------------------------------------------------
gboolean str_find_equal		(const gchar	*haystack,
				 const gchar	*needle);

文字列 haystack と文字列 needle が一致する場合に TRUE を返します。

haystack: 検索対象文字列
needle: 検索文字列
戻り値: 一致した場合 TRUE
        一致しなかった場合 FALSE

------------------------------------------------------------------------------
gboolean str_case_find_equal	(const gchar	*haystack,
				 const gchar	*needle);

文字列 haystack と文字列 needle が一致する場合に TRUE を返します。
大小文字は区別しません。

haystack: 検索対象文字列
needle: 検索文字列
戻り値: 一致した場合 TRUE
        一致しなかった場合 FALSE

------------------------------------------------------------------------------
gint to_number			(const gchar *nstr);

非負の数値文字列 nstr を整数に変換します。
nstr がヌル文字列、または数字以外の文字を含む場合は -1 を返します。

nstr: 非負の数値文字列
戻り値: nstr を整数に変換した値 (>=0)
        変換できない場合は -1

------------------------------------------------------------------------------
gchar *itos_buf			(gchar	     *nstr,
				 gint	      n);

整数 n を文字列に変換し、 nstr に格納します。
nstr は 11 バイト以上の領域でなければなりません。

nstr: 変換した文字列を格納するバッファ(11 バイト以上)
n: 変換する整数値
戻り値: nstr

------------------------------------------------------------------------------
gchar *itos			(gint	      n);

整数 n を文字列に変換し、内部で保持しているバッファへのポインタを返します。
戻り値は解放できません。次の呼び出しでバッファの内容は上書きされます。

n: 変換する整数値
戻り値: 変換した文字列を格納する内部バッファへのポインタ

------------------------------------------------------------------------------
gchar *to_human_readable	(gint64	      size);

64ビットのバイト数 size を人間が読みやすい表記(**KB 、 **MB 等)に変換します。
戻り値は解放できません。次の呼び出しでバッファの内容は上書きされます。

size: 変換する64ビットの数値
戻り値: 変換した文字列を格納する内部バッファへのポインタ

------------------------------------------------------------------------------
gint strcmp2		(const gchar	*s1,
			 const gchar	*s2);

strcmp() と同等ですが、 s1 または s2 が NULL の場合は -1 を返します。

s1: 文字列1
s2: 文字列2
戻り値: s1 > s1 の場合正の値
        s1 == s2 の場合 0
        s1 < s2 の場合負の値
        s1 または s2 が NULL の場合 -1

------------------------------------------------------------------------------
gint path_cmp		(const gchar	*s1,
			 const gchar	*s2);

パスを比較するための関数です。パスの末尾のセパレータは無視されます。
Win32 の場合、 '/' と '\' が混在していても正規化して正しく比較されます。
s1 または s2 が NULL 、あるいはヌル文字列の場合は -1 を返します。

s1: パス文字列1
s2: パス文字列2
戻り値: s1 > s1 の場合正の値
        s1 == s2 の場合 0
        s1 < s2 の場合負の値
        s1 または s2 が NULL またはヌル文字列の場合 -1

------------------------------------------------------------------------------
gchar *strretchomp	(gchar		*str);

文字列 str から末尾の改行(CR, LF)を除去します。
末尾に改行が複数ある場合もすべて除去されます。途中の改行は除去されません。

str: 文字列
戻り値: str

------------------------------------------------------------------------------
gchar *strtailchomp	(gchar		*str,
			 gchar		 tail_char);

文字列 str から末尾の tail_char を除去します。
tail_char 以外の文字が出現した時点で終了します。

str: 文字列
戻り値: str

------------------------------------------------------------------------------
gchar *strcrchomp	(gchar		*str);

文字列 str の末尾が CR+LF の場合、 LF のみに書き換えます。
途中に出現する CR は除去されません。

str: 文字列
戻り値: str

------------------------------------------------------------------------------
gchar *strcasestr	(const gchar	*haystack,
			 const gchar	*needle);

文字列 haystack 中に needle が存在する場合、 haystack 上で最初に needle が
出現した位置を返します。大小文字は区別しません。

haystack: 検索対象文字列
needle: 検索文字列
戻り値: haystack 上で最初に needle が出現した位置
        見つからなかった場合 NULL

------------------------------------------------------------------------------
gpointer my_memmem	(gconstpointer	 haystack,
			 size_t		 haystacklen,
			 gconstpointer	 needle,
			 size_t		 needlelen);

長さ haystacklen のデータ haystack 中に長さ needlelen のデータ needle
と一致する部分が存在する場合、 haystack 上で最初に needle が出現した
位置を返します。

haystack: 検索対象データ
haystacklen: haystack の長さ
needle: 検索データ
needlelen: needle の長さ
戻り値: haystack 上で最初に needle が出現した位置
        見つからなかった場合 NULL

------------------------------------------------------------------------------
gchar *strncpy2		(gchar		*dest,
			 const gchar	*src,
			 size_t		 n);

文字列 src から n 文字を超えない長さの文字を dest にコピーします。
strncpy() とは異なり、 dest は常にヌル文字で終端されます。
src の長さが n より少ない場合も dest の残りはヌル文字で埋められません。

dest: コピー先のバッファ
src: コピー元文字列
n: コピーする最大の長さ(ヌル文字を含む)
戻り値: dest

------------------------------------------------------------------------------
gboolean str_has_suffix_case	(const gchar	*str,
				 const gchar	*suffix);

文字列 str の末尾が suffix に一致するかどうかを調べます。
g_str_has_suffix() と同様ですが、大小文字を区別しません。

str: 文字列
suffix: 末尾の文字列
戻り値: str の末尾が suffix に一致する場合 TRUE
        一致しない場合 FALSE

------------------------------------------------------------------------------
gint str_find_format_times	(const gchar	*haystack,
				 gchar		 ch);

文字列 haystack 中に printf フォーマット文字列 "% + ch" が出現する回数を
数えます。文字列 "%%" はスキップします。

haystack: 検索対象文字列
ch: '%' の後に続く文字
戻り値: haystack 中に "% + ch" が出現した回数

------------------------------------------------------------------------------
gboolean is_next_nonascii	(const gchar	*s);

s から始まる次の文字列のブロック(空白が出現するまで)が非 ASCII 文字列
(8bit 文字またはコントロールコードが存在)の場合、 TRUE を返します。
s が空白で始まる場合、次の空白以外の文字までスキップされます。

s: 文字列の検索開始位置
戻り値: 次のブロックが非 ASCII 文字列の場合 TRUE
        ASCII 文字列の場合 FALSE

------------------------------------------------------------------------------
gint get_next_word_len		(const gchar	*s);

s から始まる単語(次の空白まで)の文字数を数えます。
s が空白で始まる場合は 0 が返ります。

s: 文字列の検索開始位置
戻り値: 単語の文字数

------------------------------------------------------------------------------
gint subject_compare			(const gchar	*s1,
					 const gchar	*s2);

Subject 比較用の関数です。文字列 s1 と s2 のうち比較に不要な [...] 、 (...)、
Re: などの文字列を除去した上で strcmp() による比較を行います。
s1 または s2 が NULL 、またはヌル文字列の場合は -1 を返します。

s1: 文字列1
s2: 文字列2
戻り値: s1 > s1 の場合正の値
        s1 == s2 の場合 0
        s1 < s2 の場合負の値
        s1 または s2 が NULL またはヌル文字列の場合 -1

------------------------------------------------------------------------------
gint subject_compare_for_sort		(const gchar	*s1,
					 const gchar	*s2);

Subject によるソート用の比較関数です。文字列 s1 と s2 のうち比較に不要な
Re: などのヘッダを除去した上で g_ascii_strcasecmp() による比較を行います。
s1 または s2 が NULL の場合は -1 を返します。

s1: 文字列1
s2: 文字列2
戻り値: s1 > s1 の場合正の値
        s1 == s2 の場合 0
        s1 < s2 の場合負の値
        s1 または s2 が NULL の場合 -1

------------------------------------------------------------------------------
void trim_subject_for_compare		(gchar		*str);

文字列 str から Subject の比較に不要な [...] 、 (...)、 Re: などの文字列を
除去します。

str: Subject 文字列

------------------------------------------------------------------------------
void trim_subject_for_sort		(gchar		*str);

文字列 str から Subject によるソート用の比較に不要な Re: などのヘッダを
除去します。

str: Subject 文字列

------------------------------------------------------------------------------
void trim_subject			(gchar		*str);

文字列 str から Subject の簡略表示用に [...] 、 (...) などのヘッダを除去
します。 "Re:" は適切にスキップされます。

str: Subject 文字列

------------------------------------------------------------------------------
void eliminate_parenthesis		(gchar		*str,
					 gchar		 op,
					 gchar		 cl);

文字列 str から文字 op と cl で囲まれた部分を除去します。

str: 文字列
op: 空き括弧文字
cl: 閉じ括弧文字

------------------------------------------------------------------------------
void extract_parenthesis		(gchar		*str,
					 gchar		 op,
					 gchar		 cl);

文字列 str から文字 op と cl で囲まれた部分を抽出します。
括弧文字自体は処理後の文字列には含まれません。

str: 文字列
op: 空き括弧文字
cl: 閉じ括弧文字

------------------------------------------------------------------------------
void extract_parenthesis_with_skip_quote	(gchar		*str,
						 gchar		 quote_chr,
						 gchar		 op,
						 gchar		 cl);

文字列 str から文字 op と cl で囲まれた部分を除去します。ただし、
文字 quote_chr で囲まれた部分はスキップします。

str: 文字列
quote_chr: 引用文字
op: 空き括弧文字
cl: 閉じ括弧文字

------------------------------------------------------------------------------
void eliminate_quote			(gchar		*str,
					 gchar		 quote_chr);

文字列 str から文字 quote_chr で囲まれた部分を除去します。

str: 文字列
quote_chr: 引用文字

------------------------------------------------------------------------------
void extract_quote			(gchar		*str,
					 gchar		 quote_chr);

文字列 str から文字 quote_chr で囲まれた部分を抽出します。
最初に現れた部分のみが抽出されます。

str: 文字列
quote_chr: 引用文字

------------------------------------------------------------------------------
void eliminate_address_comment		(gchar		*str);

メールアドレス文字列 str から "" や () で囲まれたコメント部分を除去します。

str: メールアドレス文字列

------------------------------------------------------------------------------
gchar *strchr_with_skip_quote		(const gchar	*str,
					 gint		 quote_chr,
					 gint		 c);

文字列 str から文字 c が最初に現れた位置を返します。
ただし文字 quote_chr で囲まれた部分は無視します。

str: 検索対象文字列
quote_chr: 引用文字
c: 検索文字
戻り値: str 上で c が最初に現れた位置

------------------------------------------------------------------------------
gchar *strrchr_with_skip_quote		(const gchar	*str,
					 gint		 quote_chr,
					 gint		 c);

文字列 str から文字 c が最後に現れた位置を返します。
ただし文字 quote_chr で囲まれた部分は無視します。

str: 検索対象文字列
quote_chr: 引用文字
c: 検索文字
戻り値: str 上で c が最後に現れた位置

------------------------------------------------------------------------------
void extract_address			(gchar		*str);

メールアドレス文字列 str からアドレスのみを抽出します。

str: メールアドレス文字列

------------------------------------------------------------------------------
void extract_list_id_str		(gchar		*str);

List-Id: 文字列 str から List-Id 本体(<> で囲まれた部分)を抽出します。

str: List-Id: 文字列

------------------------------------------------------------------------------
gchar *normalize_address_field		(const gchar	*str);

複数のメールアドレスからなる文字列 str を正規化します。結果は新たにメモリを
確保して返されます。 g_free() で解放する必要があります。

str: メールアドレス文字列

------------------------------------------------------------------------------
gboolean address_equal			(const gchar	*addr1,
					 const gchar	*addr2);

メールアドレス文字列 addr1 と addr2 が同一のアドレスである場合、 TRUE を
返します。名前やコメントは無視されます。

addr1: メールアドレス文字列1
addr2: メールアドレス文字列2
戻り値: addr1 と addr2 が同一のアドレスである場合 TRUE
        異なる場合 FALSE

------------------------------------------------------------------------------
GSList *address_list_append_orig	(GSList		*addr_list,
					 const gchar	*str);

カンマ ',' で区切られたアドレス文字列 str をアドレスごとに分解し、
各アドレスをリスト addr_list に追加します。その際名前やコメントなども
そのまま保持されます。

addr_list: メールアドレス文字列のリスト
str: メールアドレス文字列
戻り値: 更新されたメールアドレス文字列のリスト

------------------------------------------------------------------------------
GSList *address_list_append		(GSList		*addr_list,
					 const gchar	*str);

カンマ ',' で区切られたアドレス文字列 str をアドレスごとに分解し、
各アドレスをリスト addr_list に追加します。その際名前やコメントなどは
除去されます。

addr_list: メールアドレス文字列のリスト
str: メールアドレス文字列
戻り値: 更新されたメールアドレス文字列のリスト

------------------------------------------------------------------------------
GSList *references_list_prepend		(GSList		*msgid_list,
					 const gchar	*str);

References: 文字列 str を各 Message-Id 毎に分解し、リスト msgid_list に
前から追加します。

msgid_list: Message-Id 文字列のリスト
str: References: 文字列
戻り値: 更新された Message-Id 文字列のリスト

------------------------------------------------------------------------------
GSList *references_list_append		(GSList		*msgid_list,
					 const gchar	*str);

References: 文字列 str を各 Message-Id 毎に分解し、リスト msgid_list の
後に追加します。

msgid_list: Message-Id 文字列のリスト
str: References: 文字列
戻り値: 更新された Message-Id 文字列のリスト

------------------------------------------------------------------------------
GSList *newsgroup_list_append		(GSList		*group_list,
					 const gchar	*str);

カンマ ',' で区切られたニュースグループ文字列 str をグループごとに分解し、
各グループをリスト group_list に追加します。その際 "" で括られた部分は
除去されます。

group_list: ニュースグループ文字列のリスト
str: ニュースグループ文字列
戻り値: 更新されたニュースグループ文字列のリスト

------------------------------------------------------------------------------
GList *add_history			(GList		*list,
					 const gchar	*str);

ヒストリリスト list に文字列 str を前から追加します。
str に一致する古いエントリがあった場合、それは除去されます。
追加するときエントリの数が MAX_HISTORY_SIZE を超える場合は一番古いエントリが
除去されます。

list: ヒストリリスト
str: 追加する文字列
戻り値: 更新されたヒストリリスト

------------------------------------------------------------------------------
void remove_return			(gchar		*str);

文字列 str からすべての改行コード(CR, LF)を除去します。

str: 変更対象文字列

------------------------------------------------------------------------------
void remove_space			(gchar		*str);

文字列 str からすべての空白文字を除去します。

str: 変更対象文字列

------------------------------------------------------------------------------
void unfold_line			(gchar		*str);

文字列 str 中の改行文字を空白に置換した上で各行を結合します。

str: 変更対象文字列

------------------------------------------------------------------------------
void subst_char				(gchar		*str,
					 gchar		 orig,
					 gchar		 subst);

文字列 str 中の文字 orig をすべて文字 subst に置換します。

str: 変更対象文字列
orig: 置換対象文字
subst: 置換文字

------------------------------------------------------------------------------
void subst_chars			(gchar		*str,
					 gchar		*orig,
					 gchar		 subst);

文字列 str 中の文字列 orig をすべて文字 subst に置換します。

str: 変更対象文字列
orig: 置換対象文字列
subst: 置換文字

------------------------------------------------------------------------------
void subst_null				(gchar		*str,
					 gint		 len,
					 gchar		 subst);

ヌル文字を含む長さ len の文字列 str のヌル文字をすべて文字 subst に置換します。

str: 変更対象文字列
len: str の長さ
subst: 置換文字

------------------------------------------------------------------------------
void subst_control			(gchar		*str,
					 gchar		 subst);

文字列 str のコントロールコードをすべて文字 subst に置換します。

str: 変更対象文字列
subst: 置換文字

------------------------------------------------------------------------------
void subst_for_filename			(gchar		*str);

ファイル名文字列 str のうちファイル名に適さない文字を '_' に置換します。

str: 変更対象文字列

------------------------------------------------------------------------------
gchar *get_alt_filename			(const gchar	*filename,
					 gint		 count);

ファイル名 filename に番号 count の接尾辞を付加します。拡張子は保持されます。
新しいファイル名は新たにメモリを確保して返します。 g_free() で解放する
必要があります。

filename: ファイル名
count: 接尾辞の番号
戻り値: 新しいファイル名

------------------------------------------------------------------------------
gboolean is_header_line			(const gchar	*str);

文字列 str がヘッダ行("ヘッダ": "内容")である場合 TRUE を返します。

str: 文字列
戻り値: str がヘッダ行の場合 TRUE
        ヘッダ行でない場合 FALSE

------------------------------------------------------------------------------
gboolean is_ascii_str			(const gchar	*str);

文字列 str が ASCII 文字列である場合 TRUE を返します。

str: 文字列
戻り値: str が ASCII 文字列の場合 TRUE
        ASCII 文字列でない場合 FALSE

------------------------------------------------------------------------------
gint get_quote_level			(const gchar	*str);

文字列 str の引用レベルを取得します。
引用レベルは '>' の出現回数 - 1 となります。
"<...>" や "->" などは引用とみなさず無視します。

str: 文字列
戻り値: 引用レベル(>= 0)
        引用符がない場合 -1

------------------------------------------------------------------------------
gint check_line_length			(const gchar	*str,
					 gint		 max_chars,
					 gint		*line);

文字列 str の各行の文字数をチェックし、 max_chars 文字以上の行があれば -1 を
返します。すべて max_chars 文字未満であれば 0 を返します。
line が NULL でない場合は、 line に最初に現れた max_chars 以上の行の番号(0〜)を
セットします。

str: 文字列
max_chars: 許可する1行の最大文字数
line: NULL でない場合は最初に現れた max_chars 以上の行の番号(0〜)
戻り値: すべての行が max_chars 未満の場合 0
       max_chars 以上の行があった場合 -1

------------------------------------------------------------------------------
gchar *strstr_with_skip_quote		(const gchar	*haystack,
					 const gchar	*needle);

文字列 haystack から文字列 needle が最初に現れた位置を返します。
ただし ' または " で囲まれた部分は無視します。

haystack: 検索対象文字列
needle: 検索文字列
戻り値: haystack 上で needle が最初に現れた位置

------------------------------------------------------------------------------
gchar *strchr_parenthesis_close		(const gchar	*str,
					 gchar		 op,
					 gchar		 cl);

文字列 str から文字 op と cl で囲まれた部分を探し、 cl の位置を返します。
ただし " で囲まれた部分はスキップします。

str: 文字列
op: 空き括弧文字
cl: 閉じ括弧文字

------------------------------------------------------------------------------
gchar **strsplit_parenthesis		(const gchar	*str,
					 gchar		 op,
					 gchar		 cl,
					 gint		 max_tokens);

文字列 str を括弧 op と cl で囲まれたブロック毎に分割し、文字列の配列にして返します。
括弧の外側の空白は無視し、それ以外の文字列はヌル文字列として追加されます。
配列の最後の要素は NULL になります。
max_tokens が指定されいる場合、ブロックがその数に到達した時点で処理を終了します。

返った配列は g_strfreev() で解放する必要があります。

例: "(foo) (bar)" -> a[0] = "foo", a[1] = "bar", a[2] = NULL

str: 文字列
op: 空き括弧文字
cl: 閉じ括弧文字
max_tokens: 最大処理ブロック数
戻り値: 文字列へのポインタの配列(最後の要素は NULL)

------------------------------------------------------------------------------
gchar **strsplit_with_quote		(const gchar	*str,
					 const gchar	*delim,
					 gint		 max_tokens);

g_strsplit() と同様、文字列 str を区切り記号 delim で分割して文字列の配列にして
返します。ただし ' または " で囲まれた部分は無視されます。
max_tokens が指定されいる場合、トークンがその数に到達した時点で処理を終了します。

返った配列は g_strfreev() で解放する必要があります。

str: 文字列
delim: 区切り記号
max_tokens: 最大トークン数
戻り値: 文字列へのポインタの配列(最後の要素は NULL)

------------------------------------------------------------------------------
gchar *get_abbrev_newsgroup_name	(const gchar	*group,
					 gint		 len);

ニュースグループ名 group をできるだけ長さ len を超えないように簡略表記した文字列を
返します。

返った文字列は g_free() で解放する必要があります。

group: ニュースグループ文字列
len: 最大文字数
戻り値: 簡略表記したニュースグループ名

------------------------------------------------------------------------------
gchar *trim_string			(const gchar	*str,
					 gint		 len);

UTF-8 文字列 str を長さ(バイト数) len を超えないように末尾を切り詰めた文字列を返します。
切り詰めた場合、末尾に "..." が付加されます。長さは "..." を含めて len 以下となります。

返った文字列は g_free() で解放する必要があります。

str: 文字列
len: 最大文字数
戻り値: 切り詰めた文字列

------------------------------------------------------------------------------
gchar *trim_string_before		(const gchar	*str,
					 gint		 len);

UTF-8 文字列 str を長さ(バイト数) len を超えないように先頭を切り詰めた文字列を返します。
切り詰めた場合、先頭に "..." が付加されます。長さは "..." を含めて len 以下となります。

返った文字列は g_free() で解放する必要があります。

str: 文字列
len: 最大文字数
戻り値: 切り詰めた文字列

------------------------------------------------------------------------------
GList *uri_list_extract_filenames	(const gchar	*uri_list);

改行で区切られたファイル名 URI (file:) のリスト文字列を分割して通常のパスにし、
GList として返します。

返ったリストは list_free_strings() と g_list_free() で解放する必要があります。

uri_list: URI のリスト文字列
戻り値: ファイルパス文字列を要素に持つ GList

------------------------------------------------------------------------------
gboolean is_uri_string			(const gchar	*str);

文字列 str が URI または URI と推測される文字列である場合 TRUE を返します。

str: 文字列
戻り値: str が URI である場合 TRUE
       URI でない場合 FALSE

------------------------------------------------------------------------------
gchar *get_uri_path			(const gchar	*uri);

URI のスキーマ部を除いたパス部分の先頭位置を返します。
uri が URI でない場合は uri をそのまま返します。
file: URI はこの関数では URI とはみなされません。

uri: URI 文字列
戻り値: uri 上のパス部分の先頭位置

------------------------------------------------------------------------------
gint get_uri_len			(const gchar	*str);

URI 文字列 str の長さを返します。長さは URI に含まれない文字が出現したところまでに
なります。

str: URI 文字列
戻り値: URI の長さ
       str が URI でない場合は 0

------------------------------------------------------------------------------
void decode_uri				(gchar		*decoded_uri,
					 const gchar	*encoded_uri);

URI エンコードされた文字列 encoded_uri をデコードして decoded_uri に出力します。
encoded_uri と decoded_uri は同じ場所を指していても構いません。

decoded_uri: デコードした文字列を格納するバッファ
encoded_uri: URI エンコード文字列

------------------------------------------------------------------------------
void decode_xdigit_encoded_str		(gchar		*decoded,
					 const gchar	*encoded);

'%xx' の形式で16進数にエンコードされた文字列 encoded をデコードして decoded に
出力します。 encoded_uri と decoded_uri は同じ場所を指していても構いません。
decoded_uri() とは異なり、'+' はスペースに変換されません。

------------------------------------------------------------------------------
gchar *encode_uri			(const gchar	*filename);

ファイル名 filename を file: で始まる URI 文字列にエンコードします。

返った文字列は g_free() で解放する必要があります。

filename: ファイル名
戻り値: file: URI 文字列

------------------------------------------------------------------------------
gchar *uriencode_for_filename		(const gchar	*filename);

ファイル名 filename のうちファイルシステムに適さない文字を URI エンコードします。

返った文字列は g_free() で解放する必要があります。

filename: ファイル名
戻り値: URI エンコードした文字列

------------------------------------------------------------------------------
gint scan_mailto_url			(const gchar	*mailto,
					 gchar	       **to,
					 gchar	       **cc,
					 gchar	       **bcc,
					 gchar	       **subject,
					 gchar	       **body);

mailto: URL 文字列 mailto をスキャンし、各値を抽出します。
返った文字列は g_free() で解放する必要があります。

mailto: mailto: URL 文字列
to: 宛先を格納する先
cc: cc の値を格納する先
bcc: bcc の値を格納する先
subject: subject の値を格納する先
body: body (本文)の値を格納する先
戻り値: 成功した場合 0
       エラーの場合 -1

------------------------------------------------------------------------------
void set_startup_dir			(void);

カレントディレクトリを起動時のディレクトリとして記憶します。
Win32 の場合は実行ファイルのある場所にカレントディレクトリを変更し、そこを起動
ディレクトリとします。 2回目以降呼び出した場合は何もしません。

------------------------------------------------------------------------------
void set_rc_dir				(const gchar	*dir);

設定ファイルを保存するディレクトリを dir に設定します。 dir が絶対パスの場合はそれを
そのまま使用します。 dir が相対パスの場合は起動ディレクトリ以下からの相対パスと
みなされます。2回目以降呼び出した場合は前の値が上書きされます。

dir: 設定ファイルのディレクトリのパス

------------------------------------------------------------------------------
const gchar *get_startup_dir		(void);

起動ディレクトリを返します。

返った文字列は LibSylph 内部で保持しているため、解放できません。

戻り値: 起動ディレクトリ

------------------------------------------------------------------------------
const gchar *get_home_dir		(void);

ホームディレクトリを返します。

返った文字列は LibSylph 内部で保持しているため、解放できません。

戻り値: ホームディレクトリ

------------------------------------------------------------------------------
const gchar *get_document_dir		(void);

ドキュメントを保存するディレクトリを返します。
Unix 系 OS の場合はホームディレクトリが返ります。
Win32 の場合は「マイ ドキュメント」フォルダが返ります。

返った文字列は LibSylph 内部で保持しているため、解放できません。

戻り値: ドキュメントディレクトリ

------------------------------------------------------------------------------
const gchar *get_rc_dir			(void);

設定ファイルを保存するディレクトリを返します。

返った文字列は LibSylph 内部で保持しているため、解放できません。

戻り値: 設定ファイルディレクトリ

------------------------------------------------------------------------------
const gchar *get_old_rc_dir		(void);

2.0 以前のバージョンの Sylpheed の設定ファイルを保存するディレクトリを返します。

返った文字列は LibSylph 内部で保持しているため、解放できません。

戻り値: 旧設定ファイルディレクトリ

------------------------------------------------------------------------------
const gchar *get_mail_base_dir		(void);

メールボックスを置くディレクトリを返します。
Unix 系 OS の場合はホームディレクトリになります。
Win32 の場合は設定ファイルディレクトリ以下の Mailboxes ディレクトリになります。

返った文字列は LibSylph 内部で保持しているため、解放できません。

戻り値: メールボックスのベースディレクトリ

------------------------------------------------------------------------------
const gchar *get_news_cache_dir		(void);

ニュースキャッシュを置くディレクトリを返します。

返った文字列は LibSylph 内部で保持しているため、解放できません。

戻り値: ニュースキャッシュのベースディレクトリ

------------------------------------------------------------------------------
const gchar *get_imap_cache_dir		(void);

IMAP キャッシュを置くディレクトリを返します。

返った文字列は LibSylph 内部で保持しているため、解放できません。

戻り値: IMAP キャッシュのベースディレクトリ

------------------------------------------------------------------------------
const gchar *get_mime_tmp_dir		(void);

MIME 添付ファイルを一時的に置くディレクトリを返します。

返った文字列は LibSylph 内部で保持しているため、解放できません。

戻り値: MIME 添付ファイルのベースディレクトリ

------------------------------------------------------------------------------
const gchar *get_template_dir		(void);

テンプレートファイルを置くディレクトリを返します。

返った文字列は LibSylph 内部で保持しているため、解放できません。

戻り値: テンプレートファイルのベースディレクトリ

------------------------------------------------------------------------------
const gchar *get_tmp_dir		(void);

一時ファイルを置くディレクトリを返します。

返った文字列は LibSylph 内部で保持しているため、解放できません。

戻り値: 一時ファイルのベースディレクトリ

------------------------------------------------------------------------------
gchar *get_tmp_file			(void);

ユニークな一時ファイル名を自動的に作成し、返します。ファイル名は get_tmp_dir() の
ディレクトリ以下の絶対パスとなります。

返った文字列は g_free() で解放する必要があります。

戻り値: ユニークな一時ファイル名の絶対パス

------------------------------------------------------------------------------
const gchar *get_domain_name		(void);

Unix 系 OS の場合、マシンのドメイン名を取得して返します。
Win32 の場合常に "unknown" が返ります。

返った文字列は LibSylph 内部で保持しているため、解放できません。

戻り値: ドメイン名文字列

------------------------------------------------------------------------------
off_t get_file_size		(const gchar	*file);

ファイル file のファイルサイズを取得します。

file: ファイルのパス
戻り値: ファイルサイズ
       エラーの場合 -1

------------------------------------------------------------------------------
off_t get_file_size_as_crlf	(const gchar	*file);

テキストファイル file の改行コードを CR+LF とした場合のファイルサイズを取得します。
ファイル末尾が改行で終わっていない場合も改行があるものとしてカウントします。

file: ファイルのパス
戻り値: ファイルサイズ
       エラーの場合 -1

------------------------------------------------------------------------------
off_t get_left_file_size	(FILE		*fp);

ファイルストリーム fp で残りの読み出せるデータのサイズを取得します。

fp: ファイルストリーム
戻り値: 残りファイルサイズ
       エラーの場合 -1

------------------------------------------------------------------------------
gboolean file_exist		(const gchar	*file,
				 gboolean	 allow_fifo);

ファイル file が存在する場合 TRUE を返します。ディレクトリなど通常ファイル以外の場合は
FALSE を返します。 allow_fifo が TRUE の場合、 FIFO ファイルも通常のファイルと
みなします。

file: ファイルのパス
allow_fifo: FIFO を許可する場合 TRUE
            許可しない場合 FALSE
戻り値: 通常ファイル file が存在する場合 TRUE
       存在しない場合、またはエラーの場合 FALSE

------------------------------------------------------------------------------
#define is_file_exist(file)		file_exist(file, FALSE)

ファイル file が存在する(FIFO 除く)場合 TRUE を返します。

------------------------------------------------------------------------------
#define is_file_or_fifo_exist(file)	file_exist(file, TRUE)

ファイル file が存在する(FIFO を含む)場合 TRUE を返します。

------------------------------------------------------------------------------
gboolean is_dir_exist		(const gchar	*dir);

ディレクトリ dir が存在する場合 TRUE を返します。ディレクトリ以外のファイルエントリ
の場合は FALSE を返します。

dir: ディレクトリのパス
戻り値: ディレクトリ dir が存在する場合は TRUE
       存在しない場合、またはエラーの場合 FALSE

------------------------------------------------------------------------------
gboolean is_file_entry_exist	(const gchar	*file);

ファイルの種類に関わらず、ファイル file のエントリが存在する場合は TRUE を返します。

file: ファイルのパス
戻り値: ファイル file のエントリが存在する場合 TRUE
       存在しない場合、またはエラーの場合 FALSE

------------------------------------------------------------------------------
gboolean dirent_is_regular_file	(struct dirent	*d);

dirent 構造体に d_type メンバが存在して使用可能な場合、それを利用してエントリが
通常ファイルかどうかを返します。 d_type が使えない場合は通常のテストが行われます。

d: 目的のエントリを指している dirent 構造体へのポインタ
戻り値: エントリが通常ファイルの場合 TRUE
       そうでない場合 FALSE

------------------------------------------------------------------------------
gboolean dirent_is_directory	(struct dirent	*d);

dirent 構造体に d_type メンバが存在して使用可能な場合、それを利用してエントリが
ディレクトリかどうかを返します。 d_type が使えない場合は通常のテストが行われます。

d: 目的のエントリを指している dirent 構造体へのポインタ
戻り値: エントリがディレクトリの場合 TRUE
       そうでない場合 FALSE

------------------------------------------------------------------------------
gint change_dir			(const gchar	*dir);

カレントディレクトリを dir に変更します。

dir: カレントディレクトリ変更先
戻り値: 成功した場合 0
        エラーの場合 -1

------------------------------------------------------------------------------
gint make_dir			(const gchar	*dir);

ディレクトリ dir を作成し、モードをユーザのみ読み、書き、実行できるように
変更します。モードが変更できなかった場合、エラーメッセージを表示しますが
エラーは返しません。

dir: 作成するディレクトリ
戻り値: 成功した場合 0
        エラーの場合 -1

------------------------------------------------------------------------------
gint make_dir_hier		(const gchar	*dir);

ディレクトリ dir を親の階層も含めて作成します。

dir: 作成するディレクトリ
戻り値: 成功した場合 0
        エラーの場合 -1

------------------------------------------------------------------------------
gint remove_all_files		(const gchar	*dir);

ディレクトリ dir 内のすべてのファイルを削除します。

dir: 削除するファイルを格納するディレクトリ
戻り値: 成功した場合 0
        エラーの場合 -1

------------------------------------------------------------------------------
gint remove_numbered_files	(const gchar	*dir,
				 guint		 first,
				 guint		 last);

ディレクトリ dir 内の first 以上 last 以下の範囲の番号ファイルを削除します。
0 と負の値は対象に含まれません。

dir: 削除するファイルを格納するディレクトリ
first: 削除する最小の番号
last: 削除する最大の番号
戻り値: 成功した場合 0
        エラーの場合 -1

------------------------------------------------------------------------------
gint remove_all_numbered_files	(const gchar	*dir);

ディレクトリ dir 内のすべての番号ファイルを削除します。

0 と負の値は対象に含まれません。

dir: 削除するファイルを格納するディレクトリ
戻り値: 成功した場合 0
        エラーの場合 -1

------------------------------------------------------------------------------
gint remove_expired_files	(const gchar	*dir,
				 guint		 hours);

ディレクトリ dir 内の、作成後 hours 時間を超える番号ファイルを削除します。

dir: 削除するファイルを格納するディレクトリ
hours: 期限切れとなる時間
戻り値: 成功した場合 0
        エラーの場合 -1

------------------------------------------------------------------------------
gint remove_dir_recursive	(const gchar	*dir);

ディレクトリ dir とそれに含まれるすべてのファイルとディレクトリを削除します。
呼び出し前のカレントディレクトリが dir 内であった場合、呼び出し後の
カレントディレクトリは dir の親ディレクトリに設定されます。

dir: 削除するディレクトリ
戻り値: 成功した場合 0
        エラーの場合 -1

------------------------------------------------------------------------------
gint rename_force		(const gchar	*oldpath,
				 const gchar	*newpath);

ファイル newpath が既に存在する場合でも強制的にファイル oldpath を newpath
にリネームします。既存のファイル newpath は削除されます。

oldpath: 変更元ファイルのパス
newpath: 変更先のパス
戻り値: 成功した場合 0
        エラーの場合 -1

------------------------------------------------------------------------------
gint copy_file			(const gchar	*src,
				 const gchar	*dest,
				 gboolean	 keep_backup);

ファイル src を dest にコピーします。 dest が既に存在する場合、それを
dest + ".bak" というファイル名に変更してからコピーを行います。
コピーに失敗した場合バックアップファイルは元に戻されます。
keep_backup が TRUE の場合そのバックアップファイルを保持します。 FALSE
の場合は削除します。

src: コピー元ファイル
dest: コピー先ファイル
keep_backup: TRUE の場合バックアップファイルを保持
             FALSE の場合保持しない
戻り値: 成功した場合 0
        エラーの場合 -1

------------------------------------------------------------------------------
gint copy_dir			(const gchar	*src,
				 const gchar	*dest);

ディレクトリ src をその中のファイルも含めて dest にコピーします。
コピーされるのは1階層のみになります(サブディレクトリはコピーされません)。
コピー先のファイルが存在した場合は上書きされます。

src: コピー元ディレクトリ
dest: コピー先ディレクトリ
戻り値: 成功した場合 0
        エラーの場合 -1

------------------------------------------------------------------------------
gint move_file			(const gchar	*src,
				 const gchar	*dest,
				 gboolean	 overwrite);

ファイル src を dest に移動します。異なるファイルシステムに移動しようとして
失敗した場合は、ファイルのコピーと削除により移動を行います。
overwrite が FALSE の場合、 dest が既に存在する場合エラーとなります。

src: 移動元ファイル
dest: 移動先ファイル
overwrite: TRUE の場合上書きを許可
           FALSE の場合上書きを許可しない
戻り値: 成功した場合 0
        エラーの場合 -1

------------------------------------------------------------------------------
gint copy_file_part		(FILE		*fp,
				 off_t		 offset,
				 size_t		 length,
				 const gchar	*dest);

ファイルストリーム fp のファイル先頭からのオフセット位置 offset から
length バイトをファイル dest にコピーします。
dest が既に存在する場合は上書きされます。
コピー後の fp の現在位置はコピーした領域の直後の位置になります。

fp: コピー元ファイルストリーム
offset: ファイル先頭からのオフセット位置
length: コピーするバイト数
dest: コピー先ファイル
戻り値: 成功した場合 0
        エラーの場合 -1

------------------------------------------------------------------------------
gchar *canonicalize_str		(const gchar	*str);

文字列 str の改行コードを CR+LF に正規化し、新たにメモリを確保して返します。
文字列の最後が改行で終了していない場合は改行が付加されます。

返った文字列は g_free() で解放する必要があります。

str: 変換元文字列
戻り値: 正規化された文字列

------------------------------------------------------------------------------
gint canonicalize_file		(const gchar	*src,
				 const gchar	*dest);

ファイル src の改行コードを CR+LF に正規化し、ファイル dest に出力します。
ファイルの最後が改行で終了していない場合は改行が付加されます。
dest が既に存在する場合は上書きされます。

src: 変換元ファイル
dest: 正規化されたファイル
戻り値: 成功した場合 0
        エラーの場合 -1

------------------------------------------------------------------------------
gint canonicalize_file_replace	(const gchar	*file);

ファイル file の改行コードを CR+LF に正規化し、 file を置き換えます。
ファイルの最後が改行で終了していない場合は改行が付加されます。

file: 変換対象ファイル
戻り値: 成功した場合 0
        エラーの場合 -1

------------------------------------------------------------------------------
FILE *canonicalize_file_stream	(FILE		*fp,
				 gint		*length);

ファイルストリーム fp の改行コードを CR+LF に正規化し、読み出し可能な
一時ファイルのストリームとして出力します。一時ファイルの現在位置は
先頭になります。
ファイルの最後が改行で終了していない場合は改行が付加されます。
length が NULL でない場合は返ったデータのバイト数が返されます。

返ったファイルストリームを fclose() すると一時ファイルは自動的に削除されます。

fp: ファイルストリーム
length: 返ったデータのバイト数(NULL 可)
戻り値: 正規化されたファイルのストリーム

------------------------------------------------------------------------------
gint uncanonicalize_file	(const gchar	*src,
				 const gchar	*dest);

ファイル src の改行コードを LF に変換し、ファイル dest に出力します。
ファイルの最後が改行で終了していない場合はそのまま出力されます。
dest が既に存在する場合は上書きされます。

src: 変換元ファイル
dest: 変換先ファイル
戻り値: 成功した場合 0
        エラーの場合 -1

------------------------------------------------------------------------------
gint uncanonicalize_file_replace(const gchar	*file);

ファイル file の改行コードを LF に変換し、 file を置き換えます。
ファイルの最後が改行で終了していない場合はそのまま出力されます。

file: 変換対象ファイル
戻り値: 成功した場合 0
        エラーの場合 -1

------------------------------------------------------------------------------
gchar *normalize_newlines	(const gchar	*str);

文字列 str の改行コードを LF に変換し、新たにメモリを確保して返します。
文字列の最後が改行で終了していない場合はそのまま出力されます。

返った文字列は g_free() で解放する必要があります。

str: 変換元文字列
戻り値: 変換された文字列

------------------------------------------------------------------------------
gchar *strchomp_all		(const gchar	*str);

複数行からなる文字列 str のすべての行末の空白を除去し、新たにメモリを確保
して返します。改行コードはそのまま保持されます。

返った文字列は g_free() で解放する必要があります。

str: 変換元文字列
戻り値: 変換された文字列

------------------------------------------------------------------------------
FILE *get_outgoing_rfc2822_file	(FILE		*fp);

RFC 2822 メッセージのファイルストリーム fp を加工し、 SMTP サーバにそのまま
送信できる状態にして一時ファイルのストリームに書き出して返します。

この関数では以下のことが行われます:
  - ヘッダから Bcc: を取り除く
  - 先頭が . の行は先頭にさらに . を付加する
  - 改行コードを CR+LF に変換する

返ったファイルストリームを fclose() すると一時ファイルは自動的に削除されます。

fp: RFC 2822 ファイルのストリーム
戻り値: 変換後のファイルのストリーム

------------------------------------------------------------------------------
gchar *get_outgoing_rfc2822_str	(FILE		*fp);

RFC 2822 メッセージのファイルストリーム fp を加工し、 SMTP サーバにそのまま
送信できる状態にして、新たにメモリを確保して返します。
その他の仕様は get_outgoing_rfc2822_file() と同様です。

返った文字列は g_free() で解放する必要があります。

fp: RFC 2822 ファイルのストリーム
戻り値: 変換後の RFC 2822 メッセージ全体の文字列

------------------------------------------------------------------------------
gchar *generate_mime_boundary	(const gchar	*prefix);

MIME のパート境界のための文字列を生成します。
重複する確率を減らすため、日付とランダムな文字列が使用されます。
prefix が NULL でない場合は文字列の先頭に prefix が付加されます。
NULL の場合は "Multipart" が付加されます。

返った文字列は g_free() で解放する必要があります。

prefix: 境界文字列の先頭に付ける文字列
戻り値: 生成された文字列

------------------------------------------------------------------------------
gint change_file_mode_rw	(FILE		*fp,
				 const gchar	*file);

ファイルのパーミッションをユーザの読み書きのみ許可に指定します。
fchmod() が使用可能な場合はファイルストリーム fp を使用し、
使用できない場合はファイルのパス file を使用します。

fp: ファイルストリーム
file: ファイルのパス
戻り値: 成功した場合 0
        エラーの場合 -1

------------------------------------------------------------------------------
FILE *my_tmpfile		(void);

一時ファイルのストリームを作成して返します。一時ファイルは get_tmp_dir()
で得られる一時ファイルディレクトリの下に作成されます。
ストリームのモードは "w+b" で開かれます。
この一時ファイルはストリームを fclose() すると自動的に削除されます。

戻り値: 一時ファイルのストリーム

------------------------------------------------------------------------------
FILE *str_open_as_stream	(const gchar	*str);

文字列をファイルストリームとして開きます。

返ったファイルストリームを fclose() すると一時ファイルは自動的に削除されます。

str: 文字列
戻り値: ファイルストリーム

------------------------------------------------------------------------------
gint str_write_to_file		(const gchar	*str,
				 const gchar	*file);

文字列 str をファイル file に書き出します。

str: 文字列
file: 出力先ファイルのパス
戻り値: 成功した場合 0
        エラーの場合 -1

------------------------------------------------------------------------------
gchar *file_read_to_str		(const gchar	*file);

ファイル file を読み出し、新たにメモリを確保して文字列として返します。

返った文字列は g_free() で解放する必要があります。

file: ファイルのパス
戻り値: ファイルの内容を格納した文字列
        エラーの場合 NULL

------------------------------------------------------------------------------
gchar *file_read_stream_to_str	(FILE		*fp);

ファイルストリーム fp を読み出し、新たにメモリを確保して文字列として返します。

返った文字列は g_free() で解放する必要があります。

fp: ファイルストリーム
戻り値: ファイルストリームの内容を格納した文字列
        エラーの場合 NULL

------------------------------------------------------------------------------
gint execute_async		(gchar *const	 argv[]);

文字列の配列 argv で渡されたコマンドラインを非同期で実行します。
argv の文字コードは UTF-8 を使用します。

argv: コマンドラインを格納した文字列の配列(UTF-8)
戻り値: 成功した場合 0
        エラーの場合 -1

------------------------------------------------------------------------------
gint execute_sync		(gchar *const	 argv[]);

文字列の配列 argv で渡されたコマンドラインを同期で実行します。
argv の文字コードは UTF-8 を使用します。

argv: コマンドラインを格納した文字列の配列(UTF-8)
戻り値: 成功した場合 0
        エラーの場合 -1

------------------------------------------------------------------------------
gint execute_command_line	(const gchar	*cmdline,
				 gboolean	 async);

コマンドライン cmdline を実行します。 async が TRUE の場合は非同期で実行
されます。

cmdline: コマンドライン文字列
async: TRUE の場合非同期で実行
       FALSE の場合同期で実行
戻り値: 成功した場合 0
        エラーの場合 -1

------------------------------------------------------------------------------
gint execute_open_file		(const gchar	*file,
				 const gchar	*content_type);

Win32 でファイルをシステムの関連付けに基づいてアプリケーションで開きます。
Unix 系 OS の場合は何もしません。

file: 開くファイルのパス
content_type: ファイルの MIME タイプ(現在未使用)
戻り値: 成功した場合 0
        エラーの場合 -1

------------------------------------------------------------------------------
gint execute_print_file		(const gchar	*file);

Win32 でファイルをシステムの関連付けに基づいてアプリケーションで印刷します。
Unix 系 OS の場合は何もしません。

file: 印刷するファイルのパス
戻り値: 成功した場合 0
        エラーの場合 -1

------------------------------------------------------------------------------
gchar *get_command_output	(const gchar	*cmdline);

コマンド cmdline の標準出力への出力を文字列として取得します。

返った文字列は g_free() で解放する必要があります。

cmdline: コマンドライン文字列
戻り値: 標準出力への出力

------------------------------------------------------------------------------
gint open_uri(const gchar *uri, const gchar *cmdline);

URI を cmdline で指定した外部ブラウザで開きます。
Win32 の場合で cmdline が NULL またはヌル文字列の場合、システムの既定の
ブラウザで開きます。

uri: 開く URI
cmdline: ブラウザのコマンドライン文字列
戻り値: 成功した場合 0
        エラーの場合 -1

------------------------------------------------------------------------------
time_t remote_tzoffset_sec	(const gchar	*zone);

タイムゾーン文字列 zone を標準時からのオフセット(秒数)に変換して返します。
例えば、 "+0900" は 9 * 60 * 60 になります。また、 RFC で規定されている
文字列も有効です。

zone: タイムゾーン文字列
戻り値: 標準時からのオフセット(秒数)
        zone が未知の場合 -1

------------------------------------------------------------------------------
time_t tzoffset_sec		(time_t		*now);

ローカル時間と標準時のオフセットを秒数で返します。 now には基準として
適当な time_t の値の入った変数へのポインタを渡します。

now: 基準とする時間
戻り値: ローカル時間と標準時のオフセット(秒数)
        エラーの場合 -1

------------------------------------------------------------------------------
gchar *tzoffset			(time_t		*now);

ローカル時間と標準時のオフセットを "符号+時間(2桁)+分(2桁)" の形式の文字列で
返します。 now には基準として適当な time_t の値の入った変数へのポインタを
渡します。

返った文字列は LibSylph 内部で確保しているため、解放できません。

now: 基準とする時間
戻り値: ローカル時間と標準時のオフセット文字列
        エラーの場合 -1

------------------------------------------------------------------------------
void get_rfc822_date		(gchar		*buf,
				 gint		 len);

現在時刻を RFC 822 (2822) の Date ヘッダ形式の文字列で取得します。

buf: 文字列を格納するバッファ
len: buf のサイズ

------------------------------------------------------------------------------
size_t my_strftime		(gchar			*s,
				 size_t			 max,
				 const gchar		*format,
				 const struct tm	*tm);

strftime() のラッパーです。コンパイラが %c について警告を発するのを防止
できます。

s: 文字列を格納するバッファ
max: s のサイズ
format: 書式指定文字列
tm: 文字列に変換する時刻
戻り値: s に格納された文字数

------------------------------------------------------------------------------
void set_ui_update_func	(UIUpdateFunc	 func);

長い時間がかかる処理中に定期的にユーザインタフェースを更新するための
コールバック関数を指定します。

func: UIUpdateFunc 型のコールバック関数へのポインタ

------------------------------------------------------------------------------
void ui_update		(void);

ユーザインタフェースを更新するためのコールバック関数を呼び出します。
set_ui_update_func() で関数が設定されていない場合は何もしません。

------------------------------------------------------------------------------
void set_progress_func	(ProgressFunc	 func);

長い時間がかかる処理中に進捗を表示するためのコールバック関数を指定します。

func: ProgressFunc 型のコールバック関数へのポインタ

------------------------------------------------------------------------------
void progress_show	(gint		 cur,
			 gint		 total);

進捗を表示するためのコールバック関数を呼び出します。
set_progress_func() で関数が設定されていない場合は何もしません。

cur: 現在のカウント(0 <= cur <= total)
total: カウントの総数

------------------------------------------------------------------------------
void set_input_query_password_func	(QueryPasswordFunc	func);

ユーザにパスワードの入力を促すためのコールバック関数を指定します。
コールバック関数では新規にメモリを確保してパスワード文字列を返す必要が
あります。

func: QueryPasswordFunc 型のコールバック関数へのポインタ

------------------------------------------------------------------------------
gchar *input_query_password	(const gchar	*server,
				 const gchar	*user);

ユーザにパスワードの入力を促すためのコールバック関数を呼び出します。

返った文字列は g_free() で解放する必要があります。

server: サーバ名
user: ユーザ名
戻り値: ユーザが入力したパスワード文字列

------------------------------------------------------------------------------
void set_log_file	(const gchar	*filename);

ログを出力するファイルを指定し、それを開きます。

filename: ログファイルのパス

------------------------------------------------------------------------------
void close_log_file	(void);

set_log_file() でログファイルを開いている場合、それを閉じます。

------------------------------------------------------------------------------
void set_log_verbosity	(gboolean	 verbose);

ログの冗長レベルを設定します。 verbose が TRUE の場合冗長レベルが 1
上がります。逆に FALSE の場合 1 下がります。

verbose: TRUE の場合冗長レベルを 1 上げる
         FALSE の場合冗長レベルを 1 下げる

------------------------------------------------------------------------------
gboolean get_debug_mode	(void);

デバッグモードが有効になっている場合 TRUE を返します。

戻り値: デバッグモードが有効の場合 TRUE
        無効の場合 FALSE

------------------------------------------------------------------------------
void set_debug_mode	(gboolean	 enable);

デバッグモードを有効または無効にします。

enable: TRUE の場合デバッグモード有効
        FALSE の場合デバッグモード無効

------------------------------------------------------------------------------
void set_log_ui_func	(LogFunc	 print_func,
			 LogFunc	 message_func,
			 LogFunc	 warning_func,
			 LogFunc	 error_func);

ログを出力した場合にユーザインタフェースに表示させるためのコールバック関数を
各ログレベル毎に指定します。

print_func: log_print() で出力するときの関数
message_func: log_message() で出力するときの関数
warning_func: log_warning() で出力するときの関数
error_func: log_error() で出力するときの関数

------------------------------------------------------------------------------
void set_log_show_status_func	(LogFunc	 status_func);

status_print() でユーザインタフェースにステータスを表示させるための
コールバック関数を指定します。

status_func: LogFunc 型のコールバック関数へのポインタ

------------------------------------------------------------------------------
void debug_print	(const gchar *format, ...);

デバッグメッセージを出力します。デバッグモードが無効の場合は何も出力しません。

format: printf 書式指定文字列

------------------------------------------------------------------------------
void status_print	(const gchar *format, ...);

ステータスメッセージを set_log_show_status_func() で指定した関数に出力します。

format: printf 書式指定文字列

------------------------------------------------------------------------------
void log_write		(const gchar	*str,
			 const gchar	*prefix);

ログメッセージをログファイルに書き出します。ログメッセージの前には時刻と
プレフィクス文字列 prefix が付加されます。ログファイルを開いていない場合は
何もしません。

str: ログメッセージ
prefix: ログメッセージの前に付加するプレフィクス(NULL 可)

------------------------------------------------------------------------------
void log_print		(const gchar *format, ...);

ログメッセージを出力します。ログメッセージの前には時刻が付加されます。
デバッグモードが有効の場合は標準出力にも出力されます。

format: printf 書式指定文字列

------------------------------------------------------------------------------
void log_message	(const gchar *format, ...);

ログメッセージを出力します。ログメッセージの前には時刻と "* message: "
という文字列が付加されます。デバッグモードが有効の場合は標準出力にも
出力されます。

format: printf 書式指定文字列

------------------------------------------------------------------------------
void log_warning	(const gchar *format, ...);

警告メッセージをログに出力します。ログメッセージの前には時刻と "** warning: "
という文字列が付加されます。デバッグモードが有効の場合は標準エラー出力にも
出力されます。

format: printf 書式指定文字列

------------------------------------------------------------------------------
void log_error		(const gchar *format, ...);

エラーメッセージをログに出力します。ログメッセージの前には時刻と "*** error: "
という文字列が付加されます。デバッグモードが有効の場合は標準エラー出力にも
出力されます。

format: printf 書式指定文字列
